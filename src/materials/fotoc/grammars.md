---
title: '[FOTOC] Grammars'
---

# Grammars

## Introduction to Grammars

In the theory of computation, a **grammar** is a formal system used to define a language by specifying rules for generating strings. Grammars are fundamental to understanding how languages are structured and how they can be recognized or generated by computational models like automata.

## Grammar Definition

A **grammar** $G$ is a quadruple $G = (N, \Sigma, P, S)$, where:

- $N$ is a finite set of **nonterminal symbols** (also called **variables**), which act as placeholders during the generation of strings
- $\Sigma$ is a finite set of **terminal symbols**, which are the actual symbols of the language (like letters in an alphabet)
- $N \cap \Sigma = \emptyset$, meaning the sets of nonterminals and terminals are disjoint (they have no symbols in common)
- $S \in N$ is the **start symbol** (or initial symbol)
- $P$ is a finite set of **productions** (or derivation rules) of the form $x \to y$, where:
  - $x \in (N \cup \Sigma)^* N (N \cup \Sigma)^*$, meaning $x$ must contain at least one nonterminal symbol
  - $y \in (N \cup \Sigma)^*$, meaning $y$ can be any string of terminals and/or nonterminals, including the empty string $\varepsilon$

#### Observation

Note that $(N \cup \Sigma)^* - \Sigma^* = (N \cup \Sigma)^* N (N \cup \Sigma)^*$.

This means that any string over $N \cup \Sigma$ that is not purely terminals (i.e., contains at least one nonterminal) can be written as $u_1 A u_2$, where $A \in N$ and $u_1, u_2 \in (N \cup \Sigma)^*$.

## Derivation in a Grammar

Derivation is the process of generating words using the production rules of a grammar. It starts with the start symbol and applies rules to produce new words.

### One-Step Derivation

Let $G = (N, \Sigma, P, S)$ be a grammar, and let $u, v \in (N \cup \Sigma)^*$ be words.

The word $v$ can be **derived in one step** from $u$ in $G$, denoted $u \Rightarrow_G v$, if:

- $u$ can be written as $u = u_1 x u_2$
- $v$ can be written as $v = u_1 y u_2$
- $u_1, u_2 \in (N \cup \Sigma)^*$ are words (_possibly empty_)
- $x \to y \in P$, meaning there is a production rule in $P$ that allows replacing $x$ with $y$

This means we can rewrite $u$ into $v$ by applying a single production rule to replace a subword $x$ with $y$.

### Multi-Step Derivation

Let $G = (N, \Sigma, P, S)$ be a grammar, and let $u, v \in (N \cup \Sigma)^*$ be words.

The word $v$ can be **derived** from $u$ in $G$, denoted $u \Rightarrow_G^* v$, if:

- $u = v$ (no steps are needed), or
- There exists an integer $n \geq 1$ and a sequence of words $w_0, w_1, \ldots, w_n \in (N \cup \Sigma)^*$ such that:
  - $w_0 = u$ (starting word)
  - $w_n = v$ (final word)
  - $w_{i-1} \Rightarrow_G w_i$ for all $1 \leq i \leq n$ (each step is a one-step derivation)

This means $v$ can be obtained from $u$ by applying a sequence of production rules, possibly zero or more times.

#### Simplified Notation

When the grammar $G$ is context free, we often write $\Rightarrow$ instead of $\Rightarrow_G$ and $\Rightarrow^*$ instead of $\Rightarrow_G^*$.

### Sentential Forms

A word $w \in (N \cup \Sigma)^*$ is a **sentential form** if it can be derived from the start symbol $S$, i.e., $S \Rightarrow_G^* w$.

- Sentential forms may contain both terminals and nonterminals
- If a sentential form contains only terminals (i.e., $w \in \Sigma^*$), it is a word in the language generated by the grammar

## Language Generated by a Grammar

The **language generated by a grammar** $G = (N, \Sigma, P, S)$, denoted $L(G)$, is the set of all words over $\Sigma$ that can be derived from the start symbol $S$ using the production rules:

$$
L(G) := \{ w \mid S \Rightarrow_G^* w, w \in \Sigma^* \}
$$

In other words, $L(G)$ contains all words made up entirely of terminal symbols that can be produced by starting with $S$ and applying the rules in $P$ until no nonterminals remain.

### Example: Generating a Language

Consider the grammar $G = (N, \Sigma, P, S)$, where:

- $N = \{ S \}$
- $\Sigma = \{ a, b \}$
- $S$ is the start symbol
- $P = \{ S \to aSb, S \to ab \}$

Let’s derive some words:

- Start with $S$
- Apply $S \to ab$: gives $ab$
  - $ab \in \Sigma^*$, so $ab \in L(G)$
- Start with $S$
- Apply $S \to aSb$: gives $aSb$
- Apply $S \to ab$: gives $aabb$
  - $aabb \in \Sigma^*$, so $aabb \in L(G)$

If we apply $S \to aSb$ twice before using $S \to ab$, we get $aaabbb$. Continuing this pattern, the grammar generates the language:

$$
L(G) = \{ a^n b^n \mid n \geq 1 \}
$$

This language contains words with an equal number of $a$’s and $b$’s, such as $ab$, $aabb$, $aaabbb$, and so on.

## Types of Grammars (Chomsky Hierarchy)

Grammars are classified into four types based on the structure of their production rules. This classification, known as the **Chomsky Hierarchy**, defines a hierarchy of grammars and the languages they generate. The types are labeled Type 0, Type 1, Type 2, and Type 3, with each type imposing stricter constraints on the form of the production rules.

### Grammar Types

Let $G = (N, \Sigma, P, S)$ be a grammar. $G$ is a grammar of **type $i$** (where $i = 0, 1, 2, 3$) if the production rules in $P$ satisfy the following conditions:

#### Type 0: Unrestricted Grammars

- **Condition**: There are no restrictions on the form of the production rules
- Productions are of the form $x \to y$, where $x \in (N \cup \Sigma)^* N (N \cup \Sigma)^*$ (i.e., $x$ must contain at least one nonterminal) and $y \in (N \cup \Sigma)^*$
- **Generated Languages**: Unrestricted grammars generate **recursively enumerable languages**, which are the most general class of languages and correspond to languages accepted by Turing machines

#### Type 1: Context-Sensitive Grammars

- **Condition**:
  1. All production rules are of the form $u_1 A u_2 \to u_1 v u_2$, where:
     - $A \in N$ (a single nonterminal)
     - $u_1, u_2, v \in (N \cup \Sigma)^*$ (words over terminals and/or nonterminals)
     - $v \neq \varepsilon$ (the right-hand side cannot be empty)
  2. **Restricted $\varepsilon$-rule ("RER") Condition**: The only exception to the above is that $P$ may contain the rule $S \to \varepsilon$, but only if $S$ does not appear on the right-hand side of any rule in $P$
- **Approach**: The form $u_1 A u_2 \to u_1 v u_2$ means that $A$ can be replaced by $v$, but only when it appears in the specific context of $u_1$ on the left and $u_2$ on the right. Additionally, the length of the right-hand side must be at least as long as the left-hand side (except for the $S \to \varepsilon$ rule under the RER condition)
- **Generated Languages**: Context-sensitive grammars generate **context-sensitive languages**, which correspond to languages accepted by linear bounded automata (a restricted type of Turing machine)

#### Type 2: Context-Free Grammars

- **Condition**: All production rules are of the form $A \to v$, where:
  - $A \in N$ (a single nonterminal)
  - $v \in (N \cup \Sigma)^*$ (any word over terminals and/or nonterminals)
- **Approach**: The form $A \to v$ means that $A$ can be replaced by $v$ regardless of the surrounding symbols (i.e., the replacement is context-free)
- **Generated Languages**: Context-free grammars generate **context-free languages**, which correspond to languages accepted by pushdown automata (automata with a stack)
- **Example**: The grammar from the earlier example ($S \to aSb \mid ab$) is a context-free grammar because all rules are of the form $A \to v$:
  - $S \to aSb$: Here, $A = S$, $v = aSb$
  - $S \to ab$: Here, $A = S$, $v = ab$

#### Type 3: Regular Grammars

- **Condition**: All production rules are of one of the following forms:
  - $A \to u B$, or $A \to u$ where:
    - $A, B \in N$ (nonterminals)
    - $u \in \Sigma^*$ (a word over terminals, possibly empty)
- **Approach**: The form $A \to u B$ allows a nonterminal to produce a word over terminals followed by another nonterminal, while $A \to u$ allows a nonterminal to produce a word over terminals and stop. This structure mimics the behavior of a finite automaton
- **Generated Languages**: Regular grammars generate **regular languages**, which correspond to languages accepted by finite automata (the simplest computational model)
- **Example**: Consider the grammar $G = (N, \Sigma, P, S)$, where:

  - $N = \{ S, A \}$
  - $\Sigma = \{ a, b \}$
  - $S$ is the start symbol
  - $P = \{ S \to aA, A \to bA, A \to b \}$

  This is a regular grammar because:

  - $S \to aA$:

    Form $A \to u B$, with $u = a$, $B = A$.

  - $A \to bA$:

    Form $A \to u B$, with $u = b$, $B = A$.

  - $A \to b$:

    Form $A \to u$, with $u = b$.

  Let’s derive a word:

  - Start with $S$
  - Apply $S \to aA$: gives $aA$
  - Apply $A \to bA$: gives $abA$
  - Apply $A \to b$: gives $abb$

  The grammar generates the language $L(G) = \{ a b^n \mid n \geq 1 \}$, which includes words like $ab$, $abb$, $abbb$, and so on.

## Language Classes and the Chomsky Hierarchy

### Language Classes

For each type $i$ (where $i = 0, 1, 2, 3$), the **language class of type $i$**, denoted $L_i$, is the set of all languages that can be generated by a type $i$ grammar:

$$
L_i := \{ L \mid \exists G \in G_i \text{ such that } L = L(G) \}
$$

- $G_i$ denotes the set of all type $i$ grammars
- Elements of $L_i$ are called **type $i$ languages**

### Hierarchy of Language Classes

The Chomsky Hierarchy establishes a strict inclusion of language classes:

$$
L_3 \subseteq L_2 \subseteq L_1 \subseteq L_0
$$

- $L_3$: Regular languages (Type 3), generated by regular grammars
- $L_2$: Context-free languages (Type 2), generated by context-free grammars
- $L_1$: Context-sensitive languages (Type 1), generated by context-sensitive grammars
- $L_0$: Recursively enumerable languages (Type 0), generated by unrestricted grammars

This hierarchy means:

- Every regular language is also context-free
- Every context-free language is also context-sensitive
- Every context-sensitive language is also recursively enumerable

### Computational Models

Each language class corresponds to a computational model:

- **Type 0 (Recursively Enumerable)**: Accepted by Turing machines
- **Type 1 (Context-Sensitive)**: Accepted by linear bounded automata
- **Type 2 (Context-Free)**: Accepted by pushdown automata
- **Type 3 (Regular)**: Accepted by finite automata

## Classification of Grammars

A grammar $G$ can be classified based on the types of its production rules and whether it satisfies the RER condition. The possible classifications are:

- **$G \in G_3, G_2, G_1, G_0$**:
  - All rules are of Type 3, and the RER condition holds
- **$G \in G_3, G_2, G_0$**:
  - All rules are of Type 3, but the RER condition does not hold (e.g., an $\varepsilon$-rule exists that violates the RER condition)
- **$G \in G_2, G_1, G_0$**:
  - All rules are of Type 2, there is at least one non-Type 3 rule, and the RER condition holds
- **$G \in G_2, G_0$**:
  - All rules are of Type 2, there is at least one non-Type 3 rule, but the RER condition does not hold
- **$G \in G_1, G_0$**:
  - All rules are of Type 1, there is at least one non-Type 2 rule, and the RER condition holds
- **$G \in G_0$**:
  - There is at least one non-Type 1 rule, or all rules are of Type 1 but there is a non-Type 2 rule, and the RER condition does not hold

### Note on RER Condition

The **Restricted $\varepsilon$-rule (RER) Condition** applies to Type 1 (context-sensitive) grammars:

- There should be no $\varepsilon$-rules (rules of the form $x \to \varepsilon$), except possibly for $S \to \varepsilon$
- If $S \to \varepsilon$ is in $P$, then $S$ must not appear on the right-hand side of any rule in $P$

This condition ensures that the grammar adheres to the constraints of context-sensitive languages, particularly regarding the length of words during derivation.

## Normal Form for Regular Grammars (3NF)

To facilitate theoretical analysis, such as converting grammars to finite automata, it’s often useful to transform a Type 3 grammar into a **Type 3 Normal Form (3NF)**, a restricted form that simplifies the structure of production rules while preserving the language generated.

### Theorem: Type 3 Normal Form

Every Type 3 language can be generated by a Type 3 grammar $G = (N, \Sigma, P, S)$ with rules of only two forms, known as **Type 3 Normal Form (3NF)**:

- $X \to a Y$, where $X, Y \in N$ and $a \in \Sigma$ (a nonterminal produces one terminal and continues to another nonterminal), or
- $X \to \varepsilon$, where $X \in N$ (a nonterminal produces the empty string and stops).

This restricted form ensures that each rule either produces a single terminal and moves to the next step or terminates the derivation, streamlining theoretical applications like constructing finite automata.

### Algorithm: Converting a Type 3 Grammar to 3NF

A Type 3 grammar $G = (N, \Sigma, P, S)$ has rules of the form:

- **Type a)** $A \to u B$, where $A, B \in N$, $u \in \Sigma^*$ (a string of terminals, possibly empty), or
- **Type b)** $A \to u$, where $A \in N$, $u \in \Sigma^*$.

To transform $G$ into 3NF, we use a two-step algorithm: **length reduction** and **elimination of chain rules**. The resulting grammar will generate the same language (i.e., $L(G') = L(G)$) and have rules only of the form $X \to a Y$ or $X \to \varepsilon$.

#### Step 1: Length Reduction

This step ensures that each rule produces at most one terminal at a time. We break down rules that produce terminal strings longer than one symbol into a chain of single-terminal productions.

- **For Type a) Rules ($A \to u B$)**: Consider a rule $A \to u B \in P$, where $A, B \in N$, $u \in \Sigma^*$, and $|u| > 1$. Let $u = a_1 a_2 \cdots a_n$ with $n \geq 2$ and $a_i \in \Sigma$. Replace $A \to u B$ with a sequence of rules:

  $$
  A \to a_1 Z_1, \quad Z_1 \to a_2 Z_2, \quad \ldots, \quad Z_{n-1} \to a_n B
  $$

  where $Z_1, Z_2, \ldots, Z_{n-1}$ are new nonterminals not already in $N$. This creates a chain where each rule produces one terminal, passing control to the next nonterminal until reaching $B$. For example, if $u = ab$, the rule $A \to ab B$ becomes $A \to a Z_1$, $Z_1 \to b B$, ensuring each step produces exactly one terminal.

- **For Type b) Rules ($A \to u$)**: Consider a rule $A \to u \in P$, where $A \in N$, $u \in \Sigma^*$, and $|u| > 0$. Let $u = a_1 a_2 \cdots a_m$ with $m \geq 1$. Replace $A \to u$ with:
  $$
  A \to a_1 Y_1, \quad Y_1 \to a_2 Y_2, \quad \ldots, \quad Y_{m-1} \to a_m E, \quad E \to \varepsilon
  $$
  where $Y_1, Y_2, \ldots, Y_{m-1}$ and $E$ are new nonterminals ($E$ can be shared across all Type b) rules). This breaks $u$ into single-terminal steps, with $E$ producing the empty string to terminate the derivation. For example, if $u = ab$, the rule $A \to ab$ becomes $A \to a Y_1$, $Y_1 \to b E$, $E \to \varepsilon$.

**Outcome**: After this step, the grammar’s rules are of three types:

- $X \to a Y$ (one terminal, then a nonterminal),
- $X \to Y$ (chain rules, where $X, Y \in N$), or
- $X \to \varepsilon$.

The language remains unchanged because each original rule is replaced by a sequence of rules that produces the same terminal string step-by-step. No new words are introduced, and all original derivations are preserved.

#### Step 2: Elimination of Chain Rules

After Step 1, the grammar (with rule set $P_1$) may have **chain rules** of the form $X \to Y$, where $X, Y \in N$. These rules don’t produce terminals—they just pass control from one nonterminal to another. We need to remove them while ensuring the language stays the same.

- **Identify Chain Rules**: Let $P_0 \subseteq P_1$ be the set of chain rules (i.e., $X \to Y$).

- **Find Reachable Nonterminals ($H(X)$)**: For each nonterminal $X \in N$, we find all nonterminals $Y$ that $X$ can reach by following chain rules (i.e., $X \Rightarrow_G^* Y$). We compute this set, called $H(X)$, iteratively:

  - Start with $H_0(X) = \{X\}$ (just $X$ itself).
  - For $i \geq 0$, define $H_{i+1}(X)$ as $H_i(X)$ plus any nonterminal $Z$ where there’s a chain rule $Y \to Z$ with $Y \in H_i(X)$:
    $$
    H_{i+1}(X) = H_i(X) \cup \{ Z \mid Y \to Z \in P_1 \text{ and } Y \in H_i(X) \}
    $$
  - This creates a sequence $H_0(X) \subseteq H_1(X) \subseteq \cdots \subseteq N$. Since $N$ is finite, the sequence eventually stabilizes: there exists a $k$ such that $H_k(X) = H_{k+1}(X)$. We define $H(X) = H_k(X)$.

  Intuitively, $H(X)$ is the set of all nonterminals $X$ can reach by following chain rules. For example, if $X \to Y$ and $Y \to Z$, then $H(X)$ includes $\{X, Y, Z\}$.

- **Build the New Rule Set $P'$**: For each nonterminal $X$:

  - Look at all nonterminals $Y \in H(X)$ that $X$ can reach via chain rules.
  - If $Y$ has a rule $Y \to w$ in $P_1$, and it’s not a chain rule (i.e., $w$ is of the form $a Z$ or $\varepsilon$), add $X \to w$ to $P'$.
  - Exclude all chain rules from $P'$.

  Mathematically:

  $$
  P' = \{ X \to w \mid \exists Y \in H(X) \text{ such that } Y \to w \in P_1 \text{ and } w \text{ is not a nonterminal} \}
  $$

**Outcome**: This step removes all chain rules. For example, if $X \to Y$ and $Y \to a Z$, the new grammar gives $X \to a Z$ directly, bypassing the chain rule. The resulting grammar has only rules of the form $X \to a Y$ or $X \to \varepsilon$, achieving 3NF. The language remains unchanged because we’ve only removed intermediate steps (chain rules) and preserved all terminal-producing derivations.

### Why This Works

- **Step 1** breaks down terminal productions into single steps, ensuring each rule produces at most one terminal while preserving the sequence of terminals produced.
- **Step 2** removes chain rules by allowing each nonterminal to directly use the terminal-producing rules of all nonterminals it can reach, ensuring all original derivations are still possible.

The 3NF grammar is equivalent to the original and is particularly useful for constructing finite automata, as its rules directly correspond to state transitions: $X \to a Y$ represents a transition from state $X$ to state $Y$ on input $a$, and $X \to \varepsilon$ indicates that $X$ is an accepting state.

## Example 1

Find $L(G)$, determine grammar classification.

$S \to aaS \mid ba$

#### Solution

1. $S \to aaS$: rule is of the form $A \to u B$, where $A = S$, $u = aa$, $B = S$.
2. $S \to ba$: rule is of the form $A \to u$, where $A = S$, $u = ba$.

Since the grammar is simple and the rules are of Type 3 (regular), a step-by-step derivation helps reveal the pattern:

- Start with $S$.
- Apply $S \to aaS$: This gives $aaS$.
- Apply $S \to aaS$: This gives $aaaaS$.
- Apply $S \to ba$: This gives $aaaaba$.

Each application of $S \to aaS$ adds $aa$ to the front, and $S \to ba$ terminates the derivation with $ba$. After $n$ applications of $S \to aaS$ (where $n \geq 0$), we apply $S \to ba$, resulting in $a^{2n} ba$. The language is:

$$
L(G) = \{ a^{2n} ba \mid n \geq 0 \}
$$

$G \in G_3, G_2, G_1, G_0$, as all rules are of Type 3 and the RER condition holds.

## Example 2

Find $L(G)$, determine grammar classification.

$S \to aSb \mid a$

#### Solution

1. $S \to aSb$: rule is of the form $A \to v$, where $A = S$, $v = aSb$.
2. $S \to a$: rule is of the form $A \to v$, where $A = S$, $v = a$.

The rules are of Type 2 (context-free), and $S \to aSb$ is not of Type 3. A step-by-step derivation helps here:

- Start with $S$.
- Apply $S \to a$: This gives $a$.
  - $a \in \Sigma^*$, so $a \in L(G)$.
- Start with $S$.
- Apply $S \to aSb$: This gives $aSb$.
- Apply $S \to a$: This gives $aab$.
  - $aab \in \Sigma^*$, so $aab \in L(G)$.
- Apply $S \to aSb$ again: $aaSbb$, then $S \to a$, giving $aaabb$.

Notice the pattern: each application of $S \to aSb$ adds an $a$ on the left and a $b$ on the right, and $S \to a$ terminates the derivation. After applying $S \to aSb$ $n$ times (where $n \geq 0$), we apply $S \to a$, resulting in $a^{n+1} b^n$. Thus, the grammar generates the language:

$$
L(G) = \{ a^{n+1} b^n \mid n \geq 0 \}
$$

The RER condition holds (no $\varepsilon$-rules). Since all rules are of Type 2 and there is a non-Type 3 rule, the classification is:

$G \in G_2, G_1, G_0$.

## Example 3

Find $L(G)$, determine grammar classification.

$S \to aaSb \mid a \mid b$

#### Solution

1. $S \to aaSb$: rule is of the form $A \to v$, where $A = S$, $v = aaSb$.
2. $S \to a$: rule is of the form $A \to v$, where $A = S$, $v = a$.
3. $S \to b$: rule is of the form $A \to v$, where $A = S$, $v = b$.

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is at least Type 2 (context-free). The rule $S \to aaSb$ is not of the form $A \to u B$ or $A \to u$ with $u \in \Sigma^*$, so it is not Type 3. Let’s derive a few words to identify the pattern:

- Start with $S$.
- Apply $S \to a$: This gives $a$.
- Apply $S \to b$: This gives $b$.
- Apply $S \to aaSb$: This gives $aaSb$.
  - Apply $S \to a$: This gives $aaab$.
  - Or apply $S \to b$: This gives $aabb$.

Each application of $S \to aaSb$ adds $aa$ on the left and $b$ on the right. After $n$ applications of $S \to aaSb$ (where $n \geq 0$), we apply either $S \to a$ or $S \to b$, resulting in $a^{2n+1} b^n$ or $a^{2n} b^{n+1}$. Combining these, the language is:

$$
L(G) = \{ a^{2n+1} b^n \mid n \geq 0 \} \cup \{ a^{2n} b^{n+1} \mid n \geq 0 \}
$$

The RER condition holds. Since all rules are of Type 2 and there is a non-Type 3 rule, the classification is:

$G \in G_2, G_1, G_0$.

## Example 4

Find $L(G)$, determine grammar classification.

$S \to AASB \mid b$, $A \to a$, $B \to b$

#### Solution

1. $S \to AASB$: rule is of the form $A \to v$, where $A = S$, $v = AASB$.
2. $S \to b$: rule is of the form $A \to v$, where $A = S$, $v = b$.
3. $A \to a$: rule is of the form $A \to v$, where $A = A$, $v = a$.
4. $B \to b$: rule is of the form $A \to v$, where $A = B$, $v = b$.

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is at least Type 2 (context-free). The rule $S \to AASB$ is not of the form $A \to u B$ or $A \to u$ with $u \in \Sigma^*$, so it is not Type 3. Let’s derive a few words:

- Start with $S$.
- Apply $S \to b$: This gives $b$.
- Apply $S \to AASB$: This gives $AASB$.
  - Apply $A \to a$, $A \to a$, $S \to b$, $B \to b$: This gives $aabb$.

Each application of $S \to AASB$ introduces two $A$’s and one $B$. Each $A$ becomes $a$, and each $B$ becomes $b$. After $n$ applications of $S \to AASB$ (where $n \geq 0$), we apply $S \to b$, resulting in $a^{2n} b^{n+1}$. The language is:

$$
L(G) = \{ a^{2n} b^{n+1} \mid n \geq 0 \}
$$

The RER condition holds. Since all rules are of Type 2 and there is a non-Type 3 rule, the classification is:

$G \in G_2, G_1, G_0$.

## Example 5

Find $L(G)$, determine grammar classification.

$S \to AASB \mid \varepsilon$, $A \to a$, $A \to b$, $B \to b$

#### Solution

1. $S \to AASB$: rule is of the form $A \to v$, where $A = S$, $v = AASB$.
2. $S \to \varepsilon$: rule is of the form $A \to v$, where $A = S$, $v = \varepsilon$.
3. $A \to a$: rule is of the form $A \to v$, where $A = A$, $v = a$.
4. $A \to b$: rule is of the form $A \to v$, where $A = A$, $v = b$.
5. $B \to b$: rule is of the form $A \to v$, where $A = B$, $v = b$.

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is at least Type 2 (context-free). The rule $S \to AASB$ is not of the form $A \to u B$ or $A \to u$ with $u \in \Sigma^*$, so it is not Type 3. Let’s derive a few words:

- Start with $S$.
- Apply $S \to \varepsilon$: This gives $\varepsilon$.
- Apply $S \to AASB$: This gives $AASB$.
  - Apply $A \to a$, $A \to b$, $S \to \varepsilon$, $B \to b$: This gives $abb$.

Each $A$ can become either $a$ or $b$, and each $B$ becomes $b$. After $n$ applications of $S \to AASB$ (where $n \geq 0$), we apply $S \to \varepsilon$, resulting in a word with $2n$ symbols from $\{a, b\}$ (from the $A$’s) followed by $n$ $b$’s (from the $B$’s). The language is:

$$
L(G) = \{ w b^n \mid n \geq 0, w \in \{a, b\}^{2n} \}
$$

The RER condition does not hold ($S \to \varepsilon$ exists, and $S$ appears on the right-hand side of $S \to AASB$). Since all rules are of Type 2 and there is a non-Type 3 rule, the classification is:

$G \in G_2, G_0$.

## Example 6

Find $L(G)$, determine grammar classification.

$S \to aaSb \mid AA$, $A \to a \mid b$

#### Solution

1. $S \to aaSb$: rule is of the form $A \to v$, where $A = S$, $v = aaSb$.
2. $S \to AA$: rule is of the form $A \to v$, where $A = S$, $v = AA$.
3. $A \to a$: rule is of the form $A \to v$, where $A = A$, $v = a$.
4. $A \to b$: rule is of the form $A \to v$, where $A = A$, $v = b$.

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is at least Type 2 (context-free). The rules $S \to aaSb$ and $S \to AA$ are not of the form $A \to u B$ or $A \to u$ with $u \in \Sigma^*$, so it is not Type 3. Let’s derive a few words:

- Start with $S$.
- Apply $S \to AA$, $A \to a$, $A \to b$: This gives $ab$.
- Apply $S \to aaSb$: This gives $aaSb$.
  - Apply $S \to AA$, $A \to a$, $A \to b$: This gives $aaabb$.

Each application of $S \to aaSb$ adds $aa$ and $b$, and $S \to AA$ terminates with two symbols from $\{a, b\}$. After $n$ applications of $S \to aaSb$, the language is:

$$
L(G) = \{ a^{2n} w b^n \mid n \geq 0, w \in \{a, b\}^2 \}
$$

The RER condition holds (no $\varepsilon$-rules). Since all rules are of Type 2 and there is a non-Type 3 rule, the classification is:

$G \in G_2, G_1, G_0$.

## Example 7

Find $L(G)$, determine grammar classification.

$S \to aA \mid Aa$, $A \to AAA \mid a \mid b$

#### Solution

1. $S \to aA$: rule is of the form $A \to v$, where $A = S$, $v = aA$.
2. $S \to Aa$: rule is of the form $A \to v$, where $A = S$, $v = Aa$.
3. $A \to AAA$: rule is of the form $A \to v$, where $A = A$, $v = AAA$.
4. $A \to a$: rule is of the form $A \to v$, where $A = A$, $v = a$.
5. $A \to b$: rule is of the form $A \to v$, where $A = A$, $v = b$.

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is at least Type 2 (context-free). The rules $S \to aA$, $S \to Aa$, and $A \to AAA$ are not of the form $A \to u B$ or $A \to u$ with $u \in \Sigma^*$, so it is not Type 3. Let’s derive a few words:

- Start with $S$.
- Apply $S \to aA$, $A \to a$: This gives $aa$.
- Apply $S \to Aa$, $A \to b$: This gives $ba$.
- Apply $S \to aA$, $A \to AAA$, all $A \to a$: This gives $aaaa$.

After applying either $S \to aA$ or $S \to Aa$, each A can become $a$, $b$, or $AAA$. The language is:

$$
L(G) = \{ a w \mid w \in \{a, b\}^* \land |w|\ \text{is odd} \} \cup \{ w a \mid w \in \{a, b\}^* \land |w|\ \text{is odd} \}
$$

The RER condition holds (no $\varepsilon$-rules). Since all rules are of Type 2 and there is a non-Type 3 rule, the classification is:

$G \in G_2, G_1, G_0$.

## Example 8

Find $L(G)$, determine grammar classification.

$S \to aSa \mid bSb \mid \varepsilon$

#### Solution

1. $S \to aSa$: rule is of the form $A \to v$, where $A = S$, $v = aSa$.
2. $S \to bSb$: rule is of the form $A \to v$, where $A = S$, $v = bSb$.
3. $S \to \varepsilon$: rule is of the form $A \to v$, where $A = S$, $v = \varepsilon$.

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is at least Type 2 (context-free). The rules $S \to aSa$ and $S \to bSb$ are not of the form $A \to u B$ or $A \to u$ with $u \in \Sigma^*$, so it is not Type 3. The structure suggests palindromes, since $S \to aSa$ and $S \to bSb$ add matching symbols on both ends. Let’s assume words generated are palindromes and check a few iterations on the length of the word $w$:

- **Length 0**: $S \to \varepsilon$ gives $\varepsilon$, which is a palindrome.
- **Length 2**: From a word of length 0, apply $S \to aSa$: $S \Rightarrow aSa \Rightarrow a \varepsilon a = aa$. This reads the same forward and backward, so it’s a palindrome. Similarly, $S \to bSb$ gives $bb$, also a palindrome.
- **Length 4**: From a word of length 2, apply $S \to aSa$: $S \Rightarrow aSa \Rightarrow aaSaa \Rightarrow aaaa$, which is a palindrome. Or apply $S \to bSb$ to $aa$: $S \Rightarrow bSb \Rightarrow baSab \Rightarrow baab$, which is also a palindrome.

The pattern shows that each step wraps a palindrome with matching $a$’s or $b$’s, keeping the word a palindrome. The language appears to be all palindromes over $\{a, b\}$:

$$
L(G) = \{ w \in \{a, b\}^* \mid w = w^R \}
$$

The RER condition does not hold because $S \to \varepsilon$ exists, and $S$ appears on the right-hand side of other rules. Since all rules are of Type 2 and there is a non-Type 3 rule, the classification is:

$G \in G_2, G_0$.

## Example 9

Find $L(G)$, determine grammar classification.

$S \to ASA \mid BSB \mid \varepsilon$, $AB \to BA$, $BA \to AB$, $A \to a$, $B \to b$

#### Solution

1. $S \to ASA$: rule is of the form $A \to v$, where $A = S$, $v = ASA$.
2. $S \to BSB$: rule is of the form $A \to v$, where $A = S$, $v = BSB$.
3. $S \to \varepsilon$: rule is of the form $A \to v$, where $A = S$, $v = \varepsilon$.
4. $AB \to BA$: rule is of the form $x \to y$, where $x = AB$, $y = BA$.
5. $BA \to AB$: rule is of the form $x \to y$, where $x = BA$, $y = AB$.
6. $A \to a$: rule is of the form $A \to v$, where $A = A$, $v = a$.
7. $B \to b$: rule is of the form $A \to v$, where $A = B$, $v = b$.

The rules $AB \to BA$ and $BA \to AB$ are not of the form $A \to u$, so the grammar is not Type 2. They are of the form $u_1 A u_2 \to u_1 v u_2$ (e.g., for $AB \to BA$, take $u_1 = \varepsilon$, $A = AB$, $u_2 = \varepsilon$, $v = BA$), so the grammar _can be_ Type 1 (context-sensitive). The swapping rules allow any permutation of $A$’s and $B$’s. Each $S \to ASA$ or $S \to BSB$ adds symbols around a word derived from $S$, but the swapping ensures all orders are possible. The number of $A$’s and $B$’s must match, so the language is:

$$
L(G) = \{ w \in \{a, b\}^* \mid N_a(w) = N_b(w) \}
$$

Now, check the RER condition: $S \to \varepsilon$ exists, and $S$ appears on the right-hand side of $S \to ASA$ and $S \to BSB$. This violates the RER condition for Type 1 grammars, which requires that $S$ not appear on the right-hand side if $S \to \varepsilon$ is present. Since the RER condition does not hold, the grammar cannot be Type 1, despite having Type 1 rules. Therefore, the classification is:

$G \in G_0$.

## Example 10

Find $L(G)$, determine grammar classification.

$S \to ASB \mid \varepsilon$, $AB \to BA$, $BA \to AB$, $A \to a$, $B \to b$

#### Solution

1. $S \to ASB$: rule is of the form $A \to v$, where $A = S$, $v = ASB$.
2. $S \to \varepsilon$: rule is of the form $A \to v$, where $A = S$, $v = \varepsilon$.
3. $AB \to BA$: rule is of the form $x \to y$, where $x = AB$, $y = BA$.
4. $BA \to AB$: rule is of the form $x \to y$, where $x = BA$, $y = AB$.
5. $A \to a$: rule is of the form $A \to v$, where $A = A$, $v = a$.
6. $B \to b$: rule is of the form $A \to v$, where $A = B$, $v = b$.

The rules $AB \to BA$ and $BA \to AB$ are not of the form $A \to u$, so the grammar is not Type 2. They are of the form $u_1 A u_2 \to u_1 v u_2$, so the grammar _can be_ Type 1 (context-sensitive). Each $S \to ASB$ adds an $A$ and a $B$, and the swapping rules allow any permutation. After $n$ applications of $S \to ASB$, we have $n$ $A$’s and $n$ $B$’s, which can be arranged in any order. The language is:

$$
L(G) = \{ w \in \{a, b\}^* \mid N_a(w) = N_b(w) \}
$$

The RER does not hold because $S \to \varepsilon$ exists, and $S$ appears on the right-hand side.

$G \in G_0$.

## Example 11

Find $L(G)$, determine grammar classification.

$S \to ASB \mid \varepsilon$, $AB \to BA$, $A \to a$, $B \to b$

#### Solution

1. $S \to ASB$: rule is of the form $A \to v$, where $A = S$, $v = ASB$.
2. $S \to \varepsilon$: rule is of the form $A \to v$, where $A = S$, $v = \varepsilon$.
3. $AB \to BA$: rule is of the form $x \to y$, where $x = AB$, $y = BA$.
4. $A \to a$: rule is of the form $A \to v$, where $A = A$, $v = a$.
5. $B \to b$: rule is of the form $A \to v$, where $A = B$, $v = b$.

The rule $AB \to BA$ is not of the form $A \to u$, so the grammar is not Type 2. It is of the form $u_1 A u_2 \to u_1 v u_2$, so the grammar _can be_ Type 1 (context-sensitive). The language is the same as Example 10, as $BA \to AB$ is not necessary:

$$
L(G) = \{ w \in \{a, b\}^* \mid N_a(w) = N_b(w) \}
$$

Now, check the RER condition: $S \to \varepsilon$ exists, and $S$ appears on the right-hand side of $S \to ASB$, violating the RER condition for Type 1 grammars. Since the RER condition does not hold, the grammar cannot be Type 1, despite having a Type 1 rule. The classification is:

$G \in G_0$.

## Example 12

Find $L(G)$, determine grammar classification.

$S \to S' \mid \varepsilon$, $S' \to AS'B \mid AB$, $AB \to BA$, $A \to a$, $B \to b$

#### Solution

1. $S \to S'$: rule is of the form $A \to v$, where $A = S$, $v = S'$.
2. $S \to \varepsilon$: rule is of the form $A \to v$, where $A = S$, $v = \varepsilon$.
3. $S' \to AS'B$: rule is of the form $A \to v$, where $A = S'$, $v = AS'B$.
4. $S' \to AB$: rule is of the form $A \to v$, where $A = S'$, $v = AB$.
5. $AB \to BA$: rule is of the form $x \to y$, where $x = AB$, $y = BA$.
6. $A \to a$: rule is of the form $A \to v$, where $A = A$, $v = a$.
7. $B \to b$: rule is of the form $A \to v$, where $A = B$, $v = b$.

The rule $AB \to BA$ is not of the form $A \to u$, so the grammar is not Type 2. It is of the form $u_1 A u_2 \to u_1 v u_2$, so the grammar _can be_ Type 1 (context-sensitive). The $S'$ nonterminal behaves like $S$ in Example 11, generating equal numbers of $A$’s and $B$’s, which can be permuted. The language is:

$$
L(G) = \{ w \in \{a, b\}^* \mid N_a(w) = N_b(w) \}
$$

RER condition holds, $S \to \varepsilon$ exists, and $S$ does not appear on the right-hand side of any rule. Therefore, the classification is:

$G \in G_1, G_0$.

## Example 13

Find $L(G)$, determine grammar classification.

$S \to SS \mid aSb \mid bSa \mid \varepsilon$

#### Solution

1. $S \to SS$: rule is of the form $A \to v$, where $A = S$, $v = SS$.
2. $S \to aSb$: rule is of the form $A \to v$, where $A = S$, $v = aSb$.
3. $S \to bSa$: rule is of the form $A \to v$, where $A = S$, $v = bSa$.
4. $S \to \varepsilon$: rule is of the form $A \to v$, where $A = S$, $v = \varepsilon$.

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is at least Type 2 (context-free). The rules $S \to SS$, $S \to aSb$, and $S \to bSa$ are not of the form $A \to u B$ or $A \to u$ with $u \in \Sigma^*$, so it is not Type 3. The structure suggests words with equal numbers of $a$’s and $b$’s, since $S \to aSb$ and $S \to bSa$ add one $a$ and one $b$ each time. Let’s assume words have $N_a(w) = N_b(w)$ and check a few iterations:

- **Start**: $S \to \varepsilon$ gives $\varepsilon$, with $N_a = 0$, $N_b = 0$, which matches.
- **One pair**: Apply $S \to aSb$: $S \Rightarrow aSb \Rightarrow a \varepsilon b = ab$. Here, $N_a = 1$, $N_b = 1$, which matches. Similarly, $S \to bSa$ gives $ba$.
- **Two pairs**: Apply $S \to aSb$ again: $S \Rightarrow aSb \Rightarrow aaSbb \Rightarrow aabb$, with $N_a = 2$, $N_b = 2$. Or use $S \to SS$ with two words of one pair each: $S \Rightarrow SS \Rightarrow ab \cdot ab = abab$, still with $N_a = 2$, $N_b = 2$.

The pattern shows that each application of $S \to aSb$ or $S \to bSa$ adds one $a$ and one $b$, and $S \to SS$ combines words with equal counts, keeping $N_a = N_b$. The language appears to be:

$$
L(G) = \{ w \in \{a, b\}^* \mid N_a(w) = N_b(w) \}
$$

The RER condition does not hold because $S \to \varepsilon$ exists, and $S$ appears on the right-hand side of other rules. Since all rules are of Type 2 and there is a non-Type 3 rule, the classification is:

$G \in G_2, G_0$.

## Example 14

Find $L(G)$, determine grammar classification.

$S \to SS \mid (S) \mid \varepsilon$

#### Solution

1. $S \to SS$: rule is of the form $A \to v$, where $A = S$, $v = SS$.
2. $S \to (S)$: rule is of the form $A \to v$, where $A = S$, $v = (S)$.
3. $S \to \varepsilon$: rule is of the form $A \to v$, where $A = S$, $v = \varepsilon$.

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is at least Type 2 (context-free). The rules $S \to SS$ and $S \to (S)$ are not of the form $A \to u B$ or $A \to u$ with $u \in \Sigma^*$, so it is not Type 3. The structure suggests balanced parentheses, since $S \to (S)$ adds a matching pair. Let’s assume words are well-balanced (equal numbers of $($ and $)$, with no unmatched parentheses) and check a few iterations:

- **No pairs**: $S \to \varepsilon$ gives $\varepsilon$, which is balanced.
- **One pair**: Apply $S \to (S)$: $S \Rightarrow (S) \Rightarrow (\varepsilon) = ()$, which is balanced.
- **Two pairs**: Apply $S \to (S)$ again: $S \Rightarrow (S) \Rightarrow ((S)) \Rightarrow (())$, which is balanced. Or use $S \to SS$: $S \Rightarrow SS \Rightarrow () \cdot () = ()()$, also balanced.

The pattern shows that $S \to (S)$ adds a matching pair, and $S \to SS$ combines balanced sequences, keeping the word balanced. The language appears to be:

$$
L(G) = \{ w \in \{(, )\}^* \mid N_{(}(w) = N_{)}(w) \land \forall w' \in Pre(w) : N_{(}(w') \geq N_{)}(w') \}
$$

The RER condition does not hold because $S \to \varepsilon$ exists, and $S$ appears on the right-hand side of other rules. Since all rules are of Type 2 and there is a non-Type 3 rule, the classification is:

$G \in G_2, G_0$.

## Example 15

Make a grammar which generates the following language:

$$
L = \{ u \in \{0, 1\}^* \mid u \text{ starts with 0 and ends with 11} \}
$$

Determine grammar classification.

#### Solution

We need to determine $G = (N, \Sigma, P, S)$ such that $L(G) = L$. The grammar should generate words that start with 0 and end with 11.

1. $\Sigma = \{0, 1\}$.
2. $N = \{S\}$.
3. $P = \{ S \to 0A11, A \to 1 \mid 0 \mid AA \}$.
4. $S = S$.

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is at least Type 2 (context-free). The rules $A \to 1$, $A \to 0$, and $A \to AA$ are not of the form $A \to u B$ or $A \to u$ with $u \in \Sigma^*$, so it is not Type 3. The structure ensures that the word starts with 0 and ends with 11.

Grammar classification: $G \in G_2, G_1, G_0$.

## Example 16

Make a grammar which generates the following language:

$$
L = \{ u \in \{0, 1\}^* \mid u \text{ has length of at least 3} \}
$$

Determine grammar classification.

#### Solution

We need to determine $G = (N, \Sigma, P, S)$ such that $L(G) = L$. The grammar should generate words of length at least 3.

1. $\Sigma = \{0, 1\}$.
2. $P = \{ S \to AAA, A \to AA \mid 1 \mid 0 \}$.
3. $N = \{S, A\}$.
4. $S = S$.

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is at least Type 2 (context-free). The rules $A \to 1$, $A \to 0$, and $A \to AA$ are not of the form $A \to u B$ or $A \to u$ with $u \in \Sigma^*$, so it is not Type 3. The structure ensures that the word has length at least 3.

Grammar classification: $G \in G_2, G_1, G_0$.

## Example 17

Make a grammar which generates the following language:

$$
L = \{ a^n b^m c^n \mid n\geq 0, m \geq 2 \}
$$

Determine grammar classification.

#### Solution

We need to determine $G = (N, \Sigma, P, S)$ such that $L(G) = L$.

**Approach**: The language requires $n$ $a$'s, followed by $m \geq 2$ $b$'s, followed by $n$ $c$'s. We can use $S$ to generate matching $a$'s and $c$'s, and a nonterminal to produce at least two $b$'s.

- $\Sigma = \{a, b, c\}$
- $P = \{ S \to aSb \mid AA, A \to bA \mid b \}$
- $N = \{S, A\}$
- $S = S$

**Grammar Classification**:

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is Type 2 (context-free). Rules like $A \to aAc$ and $B \to BB$ include nonterminals on the right, so it’s not Type 3 (regular). There are no $\varepsilon$-rules, so the RER condition holds.

**Classification**: $G \in G_2, G_1, G_0$

## Example 18

Make a grammar which generates the following language:

$$
L = \{ a^n b^m a^{2k+1} (ac)^{m+1} c^n \mid n, m, k \geq 0 \}
$$

Determine grammar classification.

#### Solution

We need to determine $G = (N, \Sigma, P, S)$ such that $L(G) = L$.

**Approach**: The string has $n$ $a$'s, $m$ $b$'s, $2k+1$ $a$'s, $m+1$ $ac$ pairs, and $n$ $c$'s. Use $S$ to generate matching $a^n$ and $c^n$, $A$ to generate $b^m$ and $(ac)^{m+1}$, and $C$ for $a^{2k+1}$.

- $\Sigma = \{a, b, c\}$
- $P = \{ S \to aSc \mid A, A \to bBac \mid Cac, C \to a \mid CCC \}$
- $N = \{S, A, B, C\}$
- $S = S$

**Grammar Classification**:

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, making it Type 2 (context-free). Rules like $S \to aSc$ and $C \to CCC$ have nonterminals on the right, so it’s not Type 3. There are no $\varepsilon$-rules, so RER holds.

**Classification**: $G \in G_2, G_1, G_0$

## Example 19

Make a grammar which generates the following language:

$$
L = \{ u \in \{a, b\}^* \mid u \text{ contains even a's and odd b's} \}
$$

Determine grammar classification.

#### Solution

We need to determine $G = (N, \Sigma, P, S)$ such that $L(G) = L$.

**Approach**: We need to ensure an even number of $a$'s and an odd number of $b$'s. Use $A$ to generate pairs of $a$'s, $B$ to generate odd $b$'s, and a context-sensitive rule to allow reordering.

- $\Sigma = \{a, b\}$
- $P = \{ S \to AAS \mid B, B \to BBB \mid b, A \to a, AB \to BA \}$
- $N = \{S, A, B\}$
- $S = S$

**Grammar Classification**:

The rule $AB \to BA$ has a left-hand side with two nonterminals, making it Type 1 (context-sensitive) rather than Type 2. It fits the form $u_1 A u_2 \to u_1 v u_2$, and RER holds since there are no $\varepsilon$-rules.

**Classification**: $G \in G_1, G_0$

## Example 20

Make a grammar which generates the following language:

Natural numbers divisible by $3$ (no leading zeros).

Determine grammar classification.

#### Solution

We need to determine $G = (N, \Sigma, P, S)$ such that $L(G) = L$.

**Approach**: Numbers are strings over digits $\{0, 1, \ldots, 9\}$. A number is divisible by 3 if the sum of its digits is divisible by 3. We use states to track the remainder modulo 3: $A$ (remainder 0), $B$ (remainder 1), and handle transitions accordingly.

- $\Sigma = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\}$
- $P = \{ S \to A, A \to 0 \mid 3 \mid 6 \mid 9 \mid 1B \mid 4B \mid 7B, B \to 2A \mid 5A \mid 8A \}$
- $N = \{S, A, B\}$
- $S = S$

**Grammar Classification**:

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is Type 2 (context-free). Rules like $A \to 1B$ have nonterminals on the right, so it’s not Type 3. No $\varepsilon$-rules, so RER holds.

**Classification**: $G \in G_2, G_1, G_0$

## Example 21

Make a grammar which generates the following language:

$$
L = \{ u \in \{a, b, c\}^* \mid a^3 \nsubseteq u \}
$$

Determine grammar classification.

#### Solution

We need to determine $G = (N, \Sigma, P, S)$ such that $L(G) = L$.

**Approach**: The string must not contain $a^3$. After seeing one $a$, we can have at most one more $a$ before a $b$ or $c$, then reset.

- $\Sigma = \{a, b, c\}$
- $P = \{ S \to aA \mid bS \mid cS \mid a \mid b \mid c \mid \varepsilon, A \to aB \mid bS \mid cS, B \to bS \mid cS \}$
- $N = \{S, A, B\}$
- $S = S$

**Grammar Classification**:

The rules are of the form $A \to u$, where $A \in N$ and $u \in (N \cup \Sigma)^*$, so the grammar is Type 2 (context-free). Rules like $S \to aA$ have nonterminals on the right, so it’s not Type 3. The rule $S \to \varepsilon$ violates RER since $S$ appears on the right-hand side of other rules.

**Classification**: $G \in G_2, G_0$

## Example 22

Make a grammar which generates the following language:

$$
L = \{ u \in \{a, b\}^* \mid ab,bc,ca \nsubseteq u \}
$$

Determine grammar classification.

#### Solution

We need to determine $G = (N, \Sigma, P, S)$ such that $L(G) = L$.

**Approach**: The string must not contain $ab$, $bc$, or $ca$. After an $a$, only allow more $a$'s or $c$'s; after a $b$, only allow $a$'s or $b$'s; after a $c$, only allow $b$'s or $c$'s.

- $\Sigma = \{a, b, c\}$
- $P = \{ S \to aA \mid bB \mid cC \mid \varepsilon, A \to aA \mid cC \mid \varepsilon, B \to aA \mid bB \mid \varepsilon, C \to bB \mid cC \mid \varepsilon \}$
- $N = \{S, A, B, C\}$
- $S = S$

**Grammar Classification**:

The rules are of the form $A \to u$, making it Type 2 (context-free). Rules like $S \to aA$ have nonterminals on the right, so it’s not Type 3. The rule $S \to \varepsilon$ violates RER since $S$ appears on the right-hand side.

**Classification**: $G \in G_2, G_0$

## Example 23

Make a grammar which generates the following language:

$$
L = \{ a^{n^2} \mid n \geq 1 \}
$$

Determine grammar classification.

#### Solution

We need to determine $G = (N, \Sigma, P, S)$ such that $L(G) = L$.

**Approach**: We need to recognize that if we have a string of $A^nB^n$, it takes exactly $n^2$ steps to move all $B$’s to the left of all $A$’s. We can utilize this property.

Idea is to create a number of pairs of $A$’s and $B$’s first, and then on each iteration of moving $B$’s to the left, we can create an $a$. This way we will have exactly $n^2$ $a$’s.

1. $\Sigma = \{a\}$.
2. $P$

So first we need rules to generate pairs, and we need to handle cases when $A$'s and $B$'s get to most left and right position.

$S \to LS'R, S' \to AS'B \mid AB$

Those rules cover pair generation, at the end we will get something like $LAAA...BBBR$

Now we need to move $B$'s to the left, and for each movement of $B$ over $A$ spawn an $a$.

$AB \to BaA$

As we are creating $a$'s in random places, we need to make sure they will not obstruct movement of nonterminals, but mind that we don't want $A$ to ever move to the left, or $B$ to the right.

$Aa \to aA, aB \to Ba$

Finally we need to remove $A$'s and $B$'s that have reached the left and right ends.

$LB \to L, AR \to R$

And finally after we remove all $A$'s and $B$'s we need to remove $L$ and $R$.

$L \to \varepsilon, R \to \varepsilon$

So final set of rules:

$\begin{align}
P &= \{\\
&S \to LS'R,\\
&S' \to AS'B \mid AB,\\
&AB \to BaA,\\
&Aa \to aA,\\
&aB \to Ba,\\
&LB \to L,\\
&AR \to R,\\
&L \to \varepsilon,\\
&R \to \varepsilon\\
\}
\end{align}$

3. $N = \{S, S', L, R\}$.
4. $S = S$.

**Grammar Classification**:

The rules $AB \to BaA$, $Aa \to aA$, and $aB \to Ba$ make it Type 1 (context-sensitive). The rules $L \to \varepsilon$ and $R \to \varepsilon$ violate RER since $L$ and $R$ appear on the right-hand side.

**Classification**: $G \in G_0$

## Example 24

Make a grammar which generates the following language:

$$
L = \{ a^{2^n} \mid n \geq 0 \}
$$

Determine grammar classification.

#### Solution

We need to determine $G = (N, \Sigma, P, S)$ such that $L(G) = L$.

**Approach**: Here we can utilize same approach as in lat example, but instead of making pairs, we create one nonterminal which is going to roam from the most left to the most right position, and every time it goes through a terminal, we going to double it. That way number of terminals will be $2^n$.

1. $\Sigma = \{a\}$.
2. $P$

Initialize with a single terminal sequence.: $S \to LAaR$

We gotta double number of terminals when nonterminal goes right: $Aa \to aaA$

When we reach most right position we need to swap nonterminal so it can start to go left if needed:

$AR \to BR$

In the same fashion double terminal symbols when going right: $aB \to Baa$

And swap nonterminal again: $LB \to LA$

Now, only thing we need to do is terminate when nonterminal is either is at the left or right end.

$LA \to L, BR \to R, L \to \varepsilon, R \to \varepsilon$

So final set of rules:

$\begin{align}
P &= \{\\
&S \to LAaR,\\
&Aa \to aaA,\\
&AR \to BR,\\
&aB \to Baa,\\
&LB \to LA,\\
&LA \to L,\\
&BR \to R,\\
&L \to \varepsilon,\\
&R \to \varepsilon\\
\}
\end{align}$

3. $N = \{S, A, L, R, B\}$.
4. $S = S$.

**Grammar Classification**:

The rules $Aa \to aaA$ and $aB \to Baa$ are Type 1 (context-sensitive). The rules $L \to \varepsilon$ and $R \to \varepsilon$ violate RER since $L$ and $R$ appear on the right-hand side.

**Classification**: $G \in G_0$

## Example 25

Make a grammar which generates the following language:

$$
L = \{ uu \mid u \in \{a, b\}^* \}
$$

Determine grammar classification.

#### Solution

We need to determine $G = (N, \Sigma, P, S)$ such that $L(G) = L$.

**Approach**: Words we need to be should be of such a form that if split in the middle, the lift and right side would be identical, for example: ${ \color{red} abbab}{ \color{blue} abbab}$

Idea is to create pairs of terminals and respective nonterminals, and then to move all nonterminals to the right preserving order, after which convert nonterminals to terminals.

1. $\Sigma = \{a, b\}$.
2. $P$

First spawn pairs: $S \to aAS \mid bBS \mid E$

$E$ will denote the end of the string, and be used for nonterminal conversion later.

Now we need to move all nonterminals to the right:

$Aa \to aA, Ab \to bA, Ba \to aB, Bb \to bB$

And convert nonterminals to terminals:

$AE \to Ea, BE \to Eb$ and finally terminate $E \to \varepsilon$

So final set of rules:

$\begin{align}
P &= \{\\
&S \to aAS \mid bBS \mid E,\\
&Aa \to aA,\\
&Ab \to bA,\\
&Ba \to aB,\\
&Bb \to bB,\\
&AE \to Ea,\\
&BE \to Eb,\\
&E \to \varepsilon\\
\}
\end{align}$

3. $N = \{S, A, B, E\}$.
4. $S = S$.

**Grammar Classification**:

Rules like $Aa \to aA$ and $AE \to Ea$ are Type 1 (context-sensitive). The rule $E \to \varepsilon$ violates RER since $E$ appears on the right-hand side.

**Classification**: $G \in G_0$

## Example 26

Make a grammar which generates the following language:

$$
L = \{ a^n b^n c^n \mid n \in \mathbb{N} \}
$$

Determine grammar classification.

#### Solution

We need to determine $G = (N, \Sigma, P, S)$ such that $L(G) = L$.

**Approach**: Pretty much the same approach as in last example, create triples, reposition and convert

1. $\Sigma = \{a, b, c\}$.
2. $P$

First spawn triples: $S \to aSBc \mid M$

$M$ will denote the middle of the string and would allow us to convert.

Movement and conversion: $MB \to bM, cB \to Bc$

And finally terminate $M \to \varepsilon$

So final set of rules:

$$
P = \{ S \to aSBc \mid M, MB \to bM, cB \to Bc, M \to \varepsilon \}
$$

3. $N = \{S, M\}$.
4. $S = S$.

**Grammar Classification**:

Rules like $MB \to bM$ and $cB \to Bc$ are Type 1 (context-sensitive). The rule $M \to \varepsilon$ violates RER since $M$ appears on the right-hand side.

**Classification**: $G \in G_0$

## Example 27

Convert the following Type 3 grammar to Type 3 Normal Form (3NF):

- $P = \{ S \to abS, S \to B, B \to bB, B \to V, V \to aa, V \to b \}$
- $N = \{S, B, V\}$
- $\Sigma = \{a, b\}$
- $S = S$

#### Solution

We apply the two-step algorithm to transform the grammar into 3NF.

**Step 1: Length Reduction**

We break down rules that produce terminal strings longer than one symbol.

- **Rule $S \to abS$**: Here, $u = ab$ has length 2. Replace with:
  $$
  S \to a Z_1, \quad Z_1 \to b S
  $$
  where $Z_1$ is a new nonterminal.
- **Rule $S \to B$**: A chain rule (no terminals), so it stays.
- **Rule $B \to bB$**: Here, $u = b$ has length 1, so it’s already in the desired form.
- **Rule $B \to V$**: A chain rule, so it stays.
- **Rule $V \to aa$**: Here, $u = aa$ has length 2. Replace with:
  $$
  V \to a Z_2, \quad Z_2 \to a E, \quad E \to \varepsilon
  $$
  where $Z_2$ and $E$ are new nonterminals.
- **Rule $V \to b$**: Here, $u = b$ has length 1. Replace with:
  $$
  V \to b E, \quad E \to \varepsilon
  $$

After Step 1, the nonterminal set is $N' = \{S, B, V, Z_1, Z_2, E\}$, and the rule set $P_1$ is:

$\begin{align}
P_1 &= \{\\
&S \to a Z_1,\\
&Z_1 \to b S,\\
&S \to B,\\
&B \to b B,\\
&B \to V,\\
&V \to a Z_2,\\
&Z_2 \to a E,\\
&V \to b E,\\
&E \to \varepsilon\\
\}
\end{align}$

**Step 2: Elimination of Chain Rules**

The chain rules in $P_1$ are $S \to B$ and $B \to V$. We compute $H(X)$ for each nonterminal by following chain rules iteratively:

- **For $S$**:
  - $H_0(S) = \{S\}$
  - $H_1(S) = \{S, B\}$ (via $S \to B$)
  - $H_2(S) = \{S, B, V\}$ (via $B \to V$)
  - $H_3(S) = \{S, B, V\}$, so $H(S) = \{S, B, V\}$
- **For $B$**:
  - $H_0(B) = \{B\}$
  - $H_1(B) = \{B, V\}$ (via $B \to V$)
  - $H_2(B) = \{B, V\}$, so $H(B) = \{B, V\}$
- **For $V$**:
  - $H_0(V) = \{V\}$
  - $H_1(V) = \{V\}$, so $H(V) = \{V\}$
- **For $Z_1$**:
  - $H_0(Z_1) = \{Z_1\}$
  - $H_1(Z_1) = \{Z_1\}$, so $H(Z_1) = \{Z_1\}$
- **For $Z_2$**:
  - $H_0(Z_2) = \{Z_2\}$
  - $H_1(Z_2) = \{Z_2\}$, so $H(Z_2) = \{Z_2\}$
- **For $E$**:
  - $H_0(E) = \{E\}$
  - $H_1(E) = \{E\}$, so $H(E) = \{E\}$

Now, build $P'$ by adding non-chain rules based on $H(X)$:

- **From $S$ ($H(S) = \{S, B, V\}$)**:
  - $\color{green}S \to a Z_1$ (from $S$)
  - $B \to b B$, so $\color{green}S \to b B$
  - $V \to a Z_2$, so $\color{green}S \to a Z_2$
  - $V \to b E$, so $\color{green}S \to b E$
- **From $B$ ($H(B) = \{B, V\}$)**:
  - $\color{green}B \to b B$ (from $B$)
  - $V \to a Z_2$, so $\color{green}B \to a Z_2$
  - $V \to b E$, so $\color{green}B \to b E$
- **From $V$ ($H(V) = \{V\}$)**:
  - $\color{green}V \to a Z_2$
  - $\color{green}V \to b E$
- **From $Z_1$ ($H(Z_1) = \{Z_1\}$)**:
  - $\color{green}Z_1 \to b S$
- **From $Z_2$ ($H(Z_2) = \{Z_2\}$)**:
  - $\color{green}Z_2 \to a E$
- **From $E$ ($H(E) = \{E\}$)**:
  - $\color{green}E \to \varepsilon$

The final rule set $P'$, excluding chain rules, is:

$\begin{align}
P' &= \{\\
&S \to a Z_1 \mid b B \mid a Z_2 \mid b E,\\
&B \to b B \mid a Z_2 \mid b E,\\
&V \to a Z_2 \mid b E,\\
&Z_1 \to b S,\\
&Z_2 \to a E,\\
&E \to \varepsilon\\
\}
\end{align}$

The new grammar is $G' = (N', \Sigma, P', S)$, where $N' = \{S, B, V, Z_1, Z_2, E\}$. All rules are of the form $X \to a Y$ or $X \to \varepsilon$, so $G'$ is in 3NF.
